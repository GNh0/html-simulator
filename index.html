<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ÎçîÏ°¥ Í∑∏Î£πÏõ®Ïñ¥ ÏàòÏãù ÏãúÎÆ¨Î†àÏù¥ÌÑ∞ (v23 - Final)</title>
    <style>
        /* --- Layout & Reset --- */
        * { box-sizing: border-box; outline: none; }
        body { 
            font-family: 'Pretendard', 'Malgun Gothic', sans-serif; margin: 0; padding: 0; 
            background-color: #f0f2f5; height: 100vh; display: flex; overflow: hidden; 
        }
        .container { display: flex; width: 100%; height: 100%; padding: 20px; gap: 20px; }
        
        /* --- Panels --- */
        .panel { 
            background: white; border-radius: 12px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.05); display: flex; flex-direction: column; 
            overflow: hidden; border: 1px solid #e1e4e8; 
        }
        .panel.left { flex: 0 0 30%; min-width: 300px; } 
        .panel.right { flex: 1; }

        .panel-header { 
            height: 60px; min-height: 60px; padding: 0 20px; border-bottom: 1px solid #eee; 
            display: flex; align-items: center; justify-content: space-between; background: #fff; 
        }
        .panel-header h3 { margin: 0; font-size: 16px; color: #333; font-weight: 700; }
        
        /* --- Editors --- */
        .editor-area { flex: 1; overflow: hidden; }
        textarea#sourceInput { 
            width: 100%; height: 100%; border: none; padding: 20px; 
            font-family: 'D2Coding', monospace; font-size: 13px; line-height: 1.6; 
            color: #444; resize: none; background: #fafbfc; 
        }
        
        /* --- Preview --- */
        .preview-area-inner { 
            flex: 1; overflow: auto; padding: 40px; background: #f8f9fa; 
            display: flex; align-items: flex-start; justify-content: center; 
        }
        #previewContent { 
            background: white; padding: 40px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); 
            width: auto; min-width: 800px; max-width: 100%; min-height: 500px; display: inline-block; 
        }

        .btn { 
            padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; 
            font-size: 13px; font-weight: 600; display: inline-flex; align-items: center; gap: 6px; 
        }
        .btn-primary { background: #4a90e2; color: white; }
        .btn-success { background: #2ecc71; color: white; }

        /* --- Table --- */
        table { border-collapse: collapse; user-select: none; cursor: default; margin: 0 auto; }
        td { 
            border: 1px solid #dcdcdc; min-width: 50px; height: 28px; padding: 4px; 
            font-size: 12px; transition: background 0.1s; position: relative; 
        }
        td.selected-cell { background-color: #e8f0fe !important; border: 1px double #1a73e8; }
        td.editing-cell { 
            background-color: #fff !important; outline: 2px solid #1a73e8; 
            user-select: text; cursor: text; 
        }
        
        /* --- Tooltip --- */
        td[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
            background: rgba(33, 37, 41, 0.95); color: #fff; padding: 8px 12px; 
            font-size: 11px; border-radius: 4px; white-space: pre; z-index: 2000; 
            pointer-events: none; box-shadow: 0 4px 6px rgba(0,0,0,0.15); margin-bottom: 6px; 
            text-align: left; line-height: 1.5; min-width: 140px;
        }
        td[data-tooltip]:hover::before {
            content: ''; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
            border: 5px solid transparent; border-top-color: rgba(33, 37, 41, 0.95); 
            margin-bottom: -4px; z-index: 2000;
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="panel left">
            <div class="panel-header">
                <h3>HTML Source Code</h3>
                <button class="btn btn-primary" onclick="renderCode()"><span>‚ñ∂</span> Ï†ÅÏö©ÌïòÍ∏∞</button>
            </div>
            <div class="editor-area">
                <textarea id="sourceInput" placeholder="HTML ÏΩîÎìúÎ•º Î∂ôÏó¨ÎÑ£ÏúºÏÑ∏Ïöî..."></textarea>
            </div>
        </div>

        <div class="panel right">
            <div class="panel-header">
                <h3>Preview & Simulation</h3>
                <div style="display:flex; gap:10px; align-items:center;">
                    <span style="font-size:12px; color:#888;">üí° ÎçîÎ∏îÌÅ¥Î¶≠: ÏàòÏ†ï / Delete: ÏÇ≠Ï†ú</span>
                    <button class="btn btn-success" onclick="calculateAll()"><span>üîÑ</span> ÏàòÏãù Ïû¨Í≥ÑÏÇ∞</button>
                </div>
            </div>
            <div class="preview-area-inner">
                <div id="previewContent" tabindex="0"></div>
            </div>
        </div>
    </div>

    <script>
        const sourceInput = document.getElementById('sourceInput');
        const previewDiv = document.getElementById('previewContent');
        let isDragging = false;
        let startCell = null;
        let currentTable = null;

        function renderCode() {
            // [ÏàòÏ†ïÎê®] ÏûÖÎ†•Í∞íÏù¥ ÏóÜÍ±∞ÎÇò Í≥µÎ∞±ÎøêÏù¥Î©¥ ÎØ∏Î¶¨Î≥¥Í∏∞Î•º ÎπÑÏö∞Í≥† Ï¢ÖÎ£å
            if(!sourceInput.value.trim()) {
                previewDiv.innerHTML = ""; 
                return;
            }
            previewDiv.innerHTML = sourceInput.value;
            attachEvents(previewDiv);
        }

        function calculateAll() {
            runCalculationPass();
            runCalculationPass();
            updateTooltips();
        }

        function runCalculationPass() {
            const tables = previewDiv.querySelectorAll('table');
            if(tables.length === 0) return;

            tables.forEach(table => {
                const grid = mapTableToGrid(table);
                const formulaElements = table.querySelectorAll('[data-dze-formula]');

                formulaElements.forEach(el => {
                    let formula = el.getAttribute('data-dze-formula');
                    let safeFormula = formula;
                    
                    try {
                        if(safeFormula.startsWith('=')) safeFormula = safeFormula.substring(1);
                        if(safeFormula.includes("SUM")) {
                            safeFormula = safeFormula.replace(/SUM\(([^)]+)\)/g, (match, args) => {
                                if(args.includes(':')) return getRangeSum(grid, args).toString();
                                return match; 
                            });
                        }
                        safeFormula = safeFormula.replace(/\b[A-Z]+[0-9]+\b/g, (cellRef) => {
                            let val = getVal(grid, cellRef);
                            return val < 0 ? `(${val})` : val;
                        });
                        safeFormula = safeFormula.replace(/([0-9.]+)%/g, "$1*0.01");
                        if(safeFormula.includes("PRODUCT")) {
                            safeFormula = safeFormula.replace(/PRODUCT\(([^)]+)\)/g, (match, args) => {
                                const parts = args.split(',');
                                let res = 1;
                                parts.forEach(p => res *= parseFloat(new Function('return '+p)())); 
                                return res;
                            });
                        }
                        if(safeFormula.includes("SUM")) {
                            safeFormula = safeFormula.replace(/SUM\(([^)]+)\)/g, (match, args) => {
                                const parts = args.split(',');
                                let res = 0;
                                parts.forEach(p => res += parseFloat(new Function('return '+p)())); 
                                return res;
                            });
                        }

                        let resultValue = new Function('return ' + safeFormula)();
                        const pTag = el.querySelector('p') || el;
                        const hasSeparator = el.getAttribute('dze_format_separator') === ',';
                        let displayValue = Math.round(resultValue);
                        if(hasSeparator) displayValue = displayValue.toLocaleString();

                        pTag.innerText = displayValue;

                        const addr = el.getAttribute('data-addr');
                        if(addr) grid[addr] = resultValue;
                    } catch (e) { }
                });
            });
        }

        function updateTooltips() {
            const tables = previewDiv.querySelectorAll('table');
            tables.forEach(table => {
                const rows = table.rows;
                if(rows.length === 0) return;
                
                const headerMap = {};
                const firstRowCells = rows[0].cells;
                for(let c=0; c<firstRowCells.length; c++) {
                    const cell = firstRowCells[c];
                    const colIdx = parseInt(cell.getAttribute('data-col'));
                    const text = cell.innerText.trim();
                    if(text) headerMap[colIdx] = text;
                }

                const tds = table.querySelectorAll('td');
                tds.forEach(td => {
                    const colIdx = parseInt(td.getAttribute('data-col'));
                    const rowIdx = parseInt(td.getAttribute('data-row'));
                    const formula = td.getAttribute('data-dze-formula');
                    
                    let title = td.getAttribute('data-org-title');
                    if(!title) title = td.getAttribute('title');

                    if(rowIdx === 0) return;
                    let lines = [];

                    const headerName = headerMap[colIdx];
                    if(headerName) lines.push(`[${headerName}]`);

                    if(title) lines.push(`Title: ${title}`);

                    if(formula) lines.push(`ùëìùë•  ${formula}`);

                    if(lines.length > 0) {
                        td.setAttribute('data-tooltip', lines.join('\n'));
                        if(td.hasAttribute('title')) {
                            td.setAttribute('data-org-title', td.getAttribute('title'));
                            td.removeAttribute('title');
                        }
                    } else {
                        td.removeAttribute('data-tooltip');
                    }
                });
            });
        }

        function attachEvents(container) {
            const tables = container.querySelectorAll('table');
            tables.forEach(table => {
                initCoordinates(table);
                updateTooltips();

                table.addEventListener('mousedown', function(e) {
                    const td = e.target.closest('td');
                    if (!td) return;
                    container.querySelectorAll('.selected-cell').forEach(c => c.classList.remove('selected-cell'));
                    const editing = container.querySelector('.editing-cell');
                    if (editing && editing !== td) finishEdit(editing);
                    isDragging = true; startCell = td; currentTable = table;
                    selectCell(td); previewDiv.focus();
                });

                table.addEventListener('mouseover', function(e) {
                    if (!isDragging) return;
                    const td = e.target.closest('td');
                    if (!td || table !== currentTable) return;
                    selectRange(currentTable, startCell, td);
                });

                table.addEventListener('dblclick', function(e) {
                    const td = e.target.closest('td');
                    if (!td) return;
                    if(td.hasAttribute('data-dze-formula')) { alert("ÏàòÏãù ÏÖÄÏùÄ ÏàòÏ†ï Î∂àÍ∞Ä"); return; }
                    makeEditable(td);
                });
            });

            document.addEventListener('mouseup', () => isDragging = false);

            previewDiv.addEventListener('keydown', function(e) {
                if (e.key === 'Delete') {
                    const selectedCells = previewDiv.querySelectorAll('.selected-cell');
                    if(selectedCells.length > 0) {
                        selectedCells.forEach(td => {
                            if(!td.hasAttribute('data-dze-formula')) {
                                const pTag = td.querySelector('p');
                                if(pTag) pTag.innerText = ""; else td.innerText = "";
                            }
                        });
                        calculateAll();
                    }
                }
            });
        }

        function initCoordinates(table) {
            const matrix = [];
            const rows = table.rows;
            for(let r=0; r<rows.length; r++) {
                if(!matrix[r]) matrix[r] = [];
                const cells = rows[r].cells;
                let colIdx = 0;
                for(let c=0; c<cells.length; c++) {
                    while(matrix[r][colIdx]) colIdx++;
                    const cell = cells[c];
                    const rowspan = cell.rowSpan || 1;
                    const colspan = cell.colSpan || 1;
                    cell.setAttribute('data-row', r); cell.setAttribute('data-col', colIdx);
                    for(let i=0; i<rowspan; i++) {
                        for(let j=0; j<colspan; j++) {
                            if(!matrix[r+i]) matrix[r+i] = [];
                            matrix[r+i][colIdx+j] = true;
                        }
                    }
                    colIdx += colspan;
                }
            }
        }

        function mapTableToGrid(table) {
            const grid = {};
            const tds = table.querySelectorAll('td');
            tds.forEach(td => {
                const r = parseInt(td.getAttribute('data-row'));
                const c = parseInt(td.getAttribute('data-col'));
                const colLetter = getColLetter(c);
                const rowNum = r + 1;
                const address = `${colLetter}${rowNum}`;
                let text = td.innerText.replace(/,/g, '').trim();
                let val = (text === "") ? 0 : parseFloat(text);
                if(isNaN(val)) val = 0;
                grid[address] = val;
                td.setAttribute('data-addr', address);
            });
            return grid;
        }

        function getColLetter(colIndex) {
            let letter = '';
            while (colIndex >= 0) {
                letter = String.fromCharCode((colIndex % 26) + 65) + letter;
                colIndex = Math.floor(colIndex / 26) - 1;
            }
            return letter;
        }
        function getVal(grid, cellRef) { return grid[cellRef] !== undefined ? grid[cellRef] : 0; }
        function getRangeSum(grid, rangeStr) {
            const parts = rangeStr.split(':');
            const start = parts[0].trim(); const end = parts[1].trim(); 
            const startColMatch = start.match(/[A-Z]+/); const endColMatch = end.match(/[A-Z]+/);
            const startRowMatch = start.match(/\d+/); const endRowMatch = end.match(/\d+/);
            if(!startColMatch || !endColMatch || !startRowMatch || !endRowMatch) return 0;
            const startCol = startColMatch[0]; const endCol = endColMatch[0];
            const startRow = parseInt(startRowMatch[0]); const endRow = parseInt(endRowMatch[0]);
            function colToNum(col) {
                let num = 0;
                for (let i = 0; i < col.length; i++) { num = num * 26 + col.charCodeAt(i) - 64; }
                return num - 1;
            }
            const startColIdx = colToNum(startCol); const endColIdx = colToNum(endCol);
            let sum = 0;
            for(let r = startRow; r <= endRow; r++) {
                for(let c = startColIdx; c <= endColIdx; c++) {
                    const colLetter = getColLetter(c);
                    const address = `${colLetter}${r}`;
                    sum += getVal(grid, address);
                }
            }
            return sum;
        }
        
        function selectRange(table, startTd, endTd) {
            table.parentElement.querySelectorAll('.selected-cell').forEach(c => c.classList.remove('selected-cell'));
            const r1 = parseInt(startTd.getAttribute('data-row'));
            const c1 = parseInt(startTd.getAttribute('data-col'));
            const r2 = parseInt(endTd.getAttribute('data-row'));
            const c2 = parseInt(endTd.getAttribute('data-col'));
            const minR = Math.min(r1, r2); const maxR = Math.max(r1, r2);
            const minC = Math.min(c1, c2); const maxC = Math.max(c1, c2);
            const tds = table.querySelectorAll('td');
            tds.forEach(td => {
                const r = parseInt(td.getAttribute('data-row'));
                const c = parseInt(td.getAttribute('data-col'));
                if(r >= minR && r <= maxR && c >= minC && c <= maxC) td.classList.add('selected-cell');
            });
        }
        function selectCell(td) { td.classList.add('selected-cell'); }
        function makeEditable(td) {
            td.classList.remove('selected-cell');
            td.classList.add('editing-cell');
            td.setAttribute('contenteditable', 'true');
            td.focus();
            document.execCommand('selectAll', false, null);
            td.onkeydown = (e) => {
                if(e.key === 'Enter') { e.preventDefault(); finishEdit(td); }
            };
            td.onblur = () => finishEdit(td);
        }
        function finishEdit(td) {
            td.classList.remove('editing-cell');
            td.setAttribute('contenteditable', 'false');
            td.onkeydown = null; td.onblur = null;
            calculateAll();
        }
    </script>
</body>
</html>
